% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/network_survival.r
\name{network.survival.estimator_}
\alias{network.survival.estimator_}
\alias{network.survival.estimator}
\title{network survival estimator}
\usage{
network.survival.estimator_(
  resp.data,
  attribute.data,
  attribute.names,
  known.populations,
  total.kp.size = 1,
  weights,
  attribute.weights,
  within.alter.weights = NULL,
  boot.weights = NULL,
  ego.id = NULL,
  return.boot = FALSE,
  dropmiss = NULL,
  verbose = TRUE
)

network.survival.estimator(
  resp.data,
  attribute.data,
  attribute.names,
  known.populations,
  total.kp.size = 1,
  weights,
  attribute.weights,
  within.alter.weights = NULL,
  boot.weights = NULL,
  ego.id = NULL,
  return.boot = FALSE,
  dropmiss = NULL,
  verbose = TRUE
)
}
\arguments{
\item{resp.data}{The dataframe that has a row for each respondent, with reported
connections to the groups of known size, as well as the attributes.
Note that the column names of the attributes should match
their names in \code{attribute.data}}

\item{attribute.data}{A dataframe with the reported attributes of hidden population 
members reported by survey respondents. There should be one 
row for each time a respondent reports a hidden population member.
For example, to estimate death rates, there should be one row for
each report of a death.}

\item{attribute.names}{The names of the columns of attribute.data
and resp.data that contain the attribute information.}

\item{known.populations}{The names of the columns in \code{resp.data} that
have responses to the known population questions}

\item{total.kp.size}{The size of the probe alters, i.e., the sum of the known
population sizes}

\item{weights}{The weights or weights column for the respondent data}

\item{attribute.weights}{The weights or weights column for the alter data (this should typically 
be the weight of the respondent who reported the alter)}

\item{within.alter.weights}{The weight or weights column for within-alter weights. This could be useful if,
for example, respondents only report about a subset of all of their alters. See Details.}

\item{boot.weights}{Optional dataframe with bootstrap resampled weights. See Details for more info.}

\item{ego.id}{If boot.weights are included, then this is the name of the
column(s) we need to join the bootstrap weights onto the dataset. This is
most often the id of the ego making the reports.}

\item{return.boot}{If TRUE, and if \code{boot.weights} is specified, then return each bootstrap estimate}

\item{dropmiss}{See \code{\link{report.aggregator}}}

\item{verbose}{If TRUE, print information to screen}
}
\value{
the network reporting estimate of the hidden population's size
        (as a prevalence) broken down by the categories defined by all combinations
        of \code{attribute.names}.
}
\description{
use an aggregate multiplicity estimator
and the respondents' own network size estimates
to estimate hidden population sizes
}
\details{
This function takes two sources of data as input: first, it requires
a long-form dataframe with the attributes of the reported members of
the hidden population. For example, if we are asking about emigres and
we collect the age and sex of each reported emigrant, then the long form
dataset might look like:
\tabular{ccc}{
  age \tab sex \tab weight\cr
   15 \tab m   \tab 2.10  \cr
   58 \tab f   \tab 1.15  \cr
   33 \tab m   \tab 3.67  \cr
}
 
 The second source of data we need is the known population responses for the
 respondents, along with the *same* attributes for each respondent. For
 example, in the situation above, we would also require a dataset like this
 to be passed in
 \tabular{cccccc}{
  age  \tab sex  \tab  weight \tab hm.teachers \tab  hm.nurses  \tab ...  \cr
  20   \tab   f  \tab  2.10   \tab 4           \tab  0          \tab ...  \cr
  44   \tab   m  \tab  1.65   \tab 0           \tab  2          \tab ...  \cr
  60   \tab   m  \tab  2.75   \tab 1           \tab  1          \tab ...  \cr
}
}
\section{Technical note}{

This function assumes that the sampling weights are standard analysis weights
and *not* relative weights. Standard analysis weights should provide an estimate
for the size of the frame population when added up; relative weights, on the other hand,
will sum to the number of respondents in the sample.  Demographic and Health surveys
typically have relative weights, which must be converted into standard sampling weights
before using this function.
}

\section{Returned dataframe}{

Currently, the dataframe that is returned has columns for the attributes that death rates
were calculated for, along with:
\itemize{
\item{ \code{num.obs.deaths} - number of deaths reported}
\item{ \code{num.obs.degree} - number of respondents in cell used for estimating degree}
\item{ \code{y.F.Dcell.hat} - estimated total number connections from the frame to deaths}
\item{ \code{y.Fcell.kp.hat} - estimated total number of connections from (frame intersect cell) to the groups of known size}
\item{ \code{total.kp.size} - the total size of the groups of known size}
\item{ \code{N.Fcell.hat} - estimated size of (frame intersect cell) population (based on survey weights)}
\item{ \code{N.F.hat} - estimated size of frame population (based on survey weights)}
\item{ \code{asdr.hat} - the estimated death rate}
}
}

\section{TODO}{

\itemize{
\item{ handle missing values}
\item{ allow passing in N.F (currently, we always estimate from weights)}
\item{ write more general agg mult est fn and call that }
\item{ make unit tests }
}
}

\section{Details}{

If you want estimated sampling variances, you can pass in a data frame \code{boot.weights}.
\code{boot.weights} is assumed to have a column that is named whatever the \code{ego.id} is,
and then a series of columns named \code{boot_weight_1}, ..., \code{boot_weight_M}.

\code{ego.id} can either be a string or vector of strings, or it can be a named vector
like \code{c('a'='b')}. In the second case, \code{'a'} should be the name of the id column
in \code{resp.data}, while \code{'b'} should be the name of the id column in \code{'attribute.data'}.

\code{within.alter.weight} is a weight for alters within a respondent. This is set to NULL by default, and
many applications will not need it. However, it can be helpful if respondents
are only asked to report about a subset of their alters. For example, suppose that respondents can report
about 10 alters in detail. Respondent A reports connections to 3 deaths, and respondent B reports connections to
12 deaths. When aggregating Respondent A's detailed reports, we would only need to use the sampling weight.
However, if we only used the sampling weight when aggregating Respondent B's reports, that would imply that
Respondent B only reported connections to 10 deaths. In this case, setting within.alter.weight to (12/10) for
Respondent B will make B's reports imply that she reported 12 deaths. Note that this makes the assumption that
the 10 deaths Respondent B did report are a uniformly random subsample of the 12 deaths she reports being connected to.
}

